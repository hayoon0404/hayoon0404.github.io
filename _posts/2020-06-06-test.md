문제 링크 :"https://www.acmicpc.net/problem/13700"

사용 알고리즘 : BFS

해결 방법 : Queue를 활용한 BFS를 통하여 경우의 수를 탐색한다.

사용 언어 : C++

소스 : ""#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#include<stdlib.h>
#include<queue>

using namespace std;

typedef struct{
	int point;
	int cnt;
}Queue;
queue<Queue> que;

int n, s, d, f, b, k, l[500001];
int check[1000001] = { 0 };

void bfs() {
	que.push({ s,0 });
	check[s] = 1;
	while (!que.empty()){ 
		if (que.front().point == d) {
			printf("%d\n", que.front().cnt);
			return;
		}
		if (l[que.front().point + f] != 1 && que.front().point + f <= n && check[que.front().point + f] != 1) {
			que.push({ que.front().point + f,que.front().cnt + 1 });
			check[que.front().point + f] = 1;
		}
		if (l[que.front().point - b] != 1 && que.front().point - b > 0 && check[que.front().point - b] != 1) {
			que.push({ que.front().point - b,que.front().cnt + 1 });
			check[que.front().point - b] = 1;
		}
		que.pop();
	}
	printf("BUG FOUND");
	return;
}

int main() {
	int num;
	scanf("%d %d %d %d %d %d", &n, &s, &d, &f, &b, &k);
	if (k > 0) {
		for (int i = 0; i < k; i++) {
			scanf("%d", &num);
			l[num] = 1;
		}
	}
	bfs();
	return 0;
}""
